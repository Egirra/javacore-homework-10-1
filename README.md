# Домашнее задание к занятию 4.1: JVM. Организация памяти, сборщики мусора, VisualVM
## Задача 1: Задача "Понимание JVM"

### Описание
Просмотрите код ниже и опишите (текстово или с картинками) каждую строку с точки зрения происходящего в JVM  

Не забудьте упомянуть про: 
- ClassLoader'ы, 
- области памяти (стэк (и его фреймы), хип, метаспейс)  
- сборщик мусора

### Код для исследования
```java

public class JvmComprehension {

    public static void main(String[] args) {
        int i = 1;                      // 1
        Object o = new Object();        // 2
        Integer ii = 2;                 // 3
        printAll(o, i, ii);             // 4
        System.out.println("finished"); // 7
    }

    private static void printAll(Object o, int i, Integer ii) {
        Integer uselessVar = 700;                   // 5
        System.out.println(o.toString() + i + ii);  // 6
    }
}

```

## Ответ
Выполнение программы начнется с выполнения класса *JvmComprehension*. У него есть точка входа *main* и метод *printAll*.

Чтобы программу поместить в виртуальную машину, нужна будет подсистема загрузчиков классов. В обычной программе используются три загрузчика классов, которые используются в строго определенном порядке, который называется делегирование и который позволяет избежать повторной загрузки классов:
* загрузчик **Application** уровня загружает все классы;
* загрузчик **Platform**, или загрузчик классов расширений, может загружать какой-то код в каталоге расширений, который находится внутри каталога Java Home;
* загрузчик **Bootsrtap** написан на нативном коде для той платформы, на которой он работает и предназанчен для загрузки основных классов Java.

Для загрузки классов JVM обращается к подсистеме загрузчика классов и просит загрузить имеющиеся классы. Запрос уходит в ClassLoader самого верхнего уровня, при этом, чтобы избежать повторной загрузки классов, **Application ClassLoader** делегирует загрузку **Platform ClassLoader**. Тот, в свою очередь тоже ничего не загружает, а делегирует загрузку **Bootstrap ClassLoader**. У загрузчиков классов также есть свой кэш, чтобы повторно не загружать классы. Загрузчики смотрят свой кэш, и если у них нет загруженных классов, то загрузчик самого низкого уровня начинает искать эти классы и загружать их из стандартной папки Java. Если он не нашел этот класс, то он делегирует запрос ClassLoader следующего уровня, и тот проделывает те же операции.

Дальше происходит стадия связывания **Linking**. Она состоит из трех элементов:
* на стадии проверки **Verify** проводится подготовка классов к выполнению, что код валидный и с ним можно работать;
* на стадии подготовки **Prepare** происходит подготовка примитивов в статических полях;
* на стадии разрешения символьных ссылок **Resolve** происходит разрешение ссылок на другие классы, если таковые имеются.

После того, как класс загружен и проверен, статические поля подготовлены и были загружены все классы, которые есть в коде, только после этого будет выполнена стадия инициализации. Эта стадия включает в себя выполнение статических инициализаторов и инициализаторов статических полей. После этого класс считается загруженным и готовым к работе.

Готовый к работе класс загрузился в область памяти, называемую **Metaspace**, которая хранит в себе классы и системные классы.

Выполнение программы начинается с метода *main*, который является точкой входа программы. Когда мы попадем в метод *main*, в **Stack Memory** будет создана специальная область памяти, в которой будут находится все данные, которые связаны с этим методом.

Cоздается первая строчка, т.к. это значимый тип, то эта переменная будет находиться во фрейме *main* **Stack Memory** (1). Затем создается новый объект в переменную *o* и т.к. это ссылочный объект, то он создается в **heap**. В тоже время в **Stack Memory** создается ссылочная переменная *o*, куда будет сохранена ссылка на объект *Object* (2). Далее переменная *ii* добавится в область *main* в **Stack Memory**, а память для самого объекта *Integer*, который является ссылочным, выделится в **heap** (3).
``` java
int i = 1;                      // 1
Object o = new Object();        // 2
Integer ii = 2;                 // 3
```

Дальше мы видим, что идет вызов метода *printAll* и вызов метода идет с тремя переменными. В **Stack Memory** создается новый фрейм, в котором будет создано три ссылки на три объекта. В **heap** будет создан объект *Integer*, а во фрейме *printAll* создастся переменная *uselessVar* (5). Далее следует вызов системного метода *System.out.println*, и т.к. это метод, то под него выделяется новый фрейм в **Stack Memory** с тремя переменными. Метод toString() создаст новый объект, строку, который уходит в **heap**, а ссылка на него уйдет в **Stack Memory** (6).
``` java
Integer uselessVar = 700;                   // 5
System.out.println(o.toString() + i + ii);  // 6
```

Сборщик мусора (**Garbage Collector**) определяет неиспользуемые объекты либо методом подсчета ссылок, либо обходом графа достижимых объектов. И если есть объекты, на которые никто не ссылается, то их можно удалить. После завершения метода *printAll* по расписанию удалятся ссылки на объекты *uselessVar* и *o.toString()*.

После этого выполнится последний системный метод, новый объект *String* уходит в область **heap** (7).
``` java
System.out.println("finished"); // 7
```
